function withoutTrailingSlash(input = "") {
  return input.endsWith("/") ? input.slice(0, -1) : input;
}
function withTrailingSlash(input = "") {
  return input.endsWith("/") ? input : input + "/";
}
function cleanDoubleSlashes(input = "") {
  return input.split("://").map((str) => str.replace(/\/{2,}/g, "/")).join("://");
}
function hasProtocol(inputStr) {
  return /\w+:\//.test(inputStr);
}
function parseURL(input = "") {
  if (typeof input !== "string") {
    if (!input || !input.url) {
      throw new Error(`Invalid url: ${JSON.stringify(input)}`);
    }
    return input;
  }
  const _hasProtocol = hasProtocol(input);
  const isRelative = _hasProtocol ? false : input[0] !== "/";
  const url = new URL(input, _hasProtocol ? void 0 : "default:/");
  return {url, hasProtocol: _hasProtocol, isRelative};
}
function joinPath(...path) {
  const last = path.pop();
  if (!last) {
    return "";
  }
  return path.map(withoutTrailingSlash).join("") + last;
}
function normalizeURL(input, stripBase) {
  const {url, hasProtocol: hasProtocol2, isRelative} = parseURL(input);
  if (!stripBase && hasProtocol2) {
    return url.href;
  }
  const path = url.pathname + url.search + url.hash;
  return isRelative ? path.substr(1) : path;
}
function withParams(input, params) {
  const parsed = parseURL(input);
  const mergedParams = {...getParams(input), ...params};
  parsed.url.search = Object.keys(mergedParams).map((n) => {
    const val = mergedParams[n];
    return val ? `${n}=${decodeURIComponent(mergedParams[n])}` : n;
  }).join("&");
  return normalizeURL(parsed);
}
function getParams(input) {
  const parsed = parseURL(input);
  const params = {};
  parsed.url.searchParams.forEach((value, key) => {
    params[key] = value;
  });
  return params;
}
function joinURL(input0, ...input) {
  const path = input.map(parseURL);
  const baseURL = parseURL(input0);
  for (const p of path) {
    p.url.searchParams.forEach((value, key) => {
      baseURL.url.searchParams.set(key, value);
    });
  }
  baseURL.url.pathname = joinPath(baseURL.url.pathname, ...path.map((p) => p.url.pathname));
  return normalizeURL(baseURL);
}

export { cleanDoubleSlashes, getParams, hasProtocol, joinPath, joinURL, normalizeURL, parseURL, withParams, withTrailingSlash, withoutTrailingSlash };
